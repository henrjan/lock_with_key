package main

import (
	"sync"
)

type MultiLock struct {
	inUse   sync.Map
	pool    *sync.Pool
	acquire chan refKey
	release chan refKey
}

type keyLock struct {
	counter int
	lock    *sync.RWMutex
}

type refKey struct {
	wg   *sync.WaitGroup
	key  interface{}
	lock *keyLock
}

func NewMultipleLock() *MultiLock {
	mLock := &MultiLock{
		pool: &sync.Pool{
			New: func() interface{} {
				return &sync.RWMutex{}
			},
		},
		acquire: make(chan refKey, 100),
		release: make(chan refKey, 100),
	}
	go mLock.lockUnlock()
	return mLock
}

func (mLock *MultiLock) Lock(key interface{}) {
	var wg sync.WaitGroup
	wg.Add(1)
	mLock.acquire <- refKey{&wg, key, nil}
	wg.Wait()
	kl, _ := mLock.getLock(key)
	kl.lock.Lock()
}

func (mLock *MultiLock) Unlock(key interface{}) {
	var wg sync.WaitGroup
	wg.Add(1)
	kl, _ := mLock.getLock(key)
	mLock.release <- refKey{&wg, key, kl}
	wg.Wait()
	kl.lock.Unlock()
}

func (mLock *MultiLock) RLock(key interface{}) {
	var wg sync.WaitGroup
	wg.Add(1)
	mLock.acquire <- refKey{&wg, key, nil}
	wg.Wait()
	kl, _ := mLock.getLock(key)
	kl.lock.RLock()
}

func (mLock *MultiLock) RUnlock(key interface{}) {
	var wg sync.WaitGroup
	wg.Add(1)
	kl, _ := mLock.getLock(key)
	mLock.release <- refKey{&wg, key, kl}
	wg.Wait()
	kl.lock.RUnlock()
}

func (mLock *MultiLock) getLock(key interface{}) (*keyLock, bool) {
	locker, ok := mLock.inUse.Load(key)
	return locker.(*keyLock), ok
}

func (mLock *MultiLock) lockUnlock() {
	for {
		select {
		case refKey := <-mLock.acquire:
			mLock.acquireLock(refKey.key)
			refKey.wg.Done()
		case refKey := <-mLock.release:
			mLock.releaseLock(refKey.key, refKey.lock)
			refKey.wg.Done()
		default:
			// fmt.Println("Waiting...")
			// time.Sleep(time.Millisecond)
		}
	}
}

func (mLock *MultiLock) acquireLock(key interface{}) {
	locker, _ := mLock.inUse.LoadOrStore(
		key,
		&keyLock{
			lock: mLock.pool.Get().(*sync.RWMutex),
		},
	)
	kl := locker.(*keyLock)
	kl.counter++
}

func (mLock *MultiLock) releaseLock(key interface{}, kl *keyLock) {
	kl.counter--
	if kl.counter <= 0 {
		mLock.pool.Put(kl.lock)
		mLock.inUse.Delete(key)
	}
}
